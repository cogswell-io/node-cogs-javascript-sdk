### cepClient.sendEvent(namespace, eventName, attributes, tags)
All events are sent to Cogs through this route. The event data must only contain attributes valid for the namespace specified in the request. It must also include all attributes defined as primary key attributes for the namespace. These uniquely identify the topic of the event.

```javascript
var cogs = require('cogs-sdk');

var namespace = 'my-namespace';
var eventName = 'my-event'
var attributes = {
  'my-id-attribute': 12,
  'my-name': 'Bob',
  'my-boolean': true
};
var tags = ['foo', 'bar'];

cogs.cep.getClient('cogs-client.json')
.then((client) => {
  return client.sendEvent(namespace, eventName, attributes, tags);
})
.then(() => {
  console.log('Event successfully sent.');
})
.catch((error) => {
  console.error(`Error sending event: ${error}\n${error.stack}`);
});
```

### cepClient.getChannelSummary(namespace, attributes)
A summary of the most recent value for each attribute associated with a channel can be fetched via this route. This may contain values from multiple events (a event-sourced summary of the channel).

```javascript
var cogs = require('cogs-sdk');

var namespace = 'my-namespace';
var eventName = 'my-event'
var attributes = {
  'my-id-attribute': 12
};
var tags = ['foo', 'bar'];

cogs.cep.getClient('cogs-client.json')
.then(client => {
  return client.getChannelSummary(namespace, attributes);
})
.then(summary => {
  console.log('Channel summary is:', summary);
})
.catch(error => {
  console.error(`Error sending event: ${error}\n${error.stack}`);
});
```

### cepClient.getMessage(namespace, topicAttributes, messageId)
Messages generated by Cogs may be fetched by their ID. This is important for mobile devices which receive only the message ID in notifications and need to fetch the full message payload in response to the notification. This is also useful when for space constraints you wish to store only historical message IDs on a device, and fetch messages from Cogs only when you need to reference them. Keep in mind that the identified message is also paired with the namespace and topic attributes identified in the authentication payload.

```javascript
var cogs = require('cogs-sdk');

var namespace = 'my-namespace';
var topicAttributes = {
    'my-id-attribute': 12
};
var messageId = 'deadbeef-dead-beef-dead-beefdeadbeef';

cogs.cep.getClient('cogs-client.json')
.then((client) => {
  return client.getMessage(namespace, topicAttributes, messageId);
})
.then((message) => {
  console.log(`Successfully retrieved message:\n${JSON.stringify(message, null, 2)}`);
})
.catch((error) => {
  console.error(`Error fetching message '${messageId}': ${error}\n${error.stack}`);
});
```


### cepClient.subscribe(namespace, topicAttributes)
This endpoint is use to establish WebSockets in order to receive push notifications for individual topics. New messages generated for a particular topic are delivered to all WebSockets registered with that topic's identifying attributes. Unlike mobile notifications, which only contain the message ID, the payload sent over these WebSockets is the entire message payload. It does include the message ID, so you can still fetch the message again later by its ID.

```javascript
var cogs = require('cogs-sdk');

var namespace = 'my-namespace';
var topicAttributes = {
  'my-id-attribute': 12
};

cogs.cep.getClient('cogs-client.json')
.then(client => {
  return new Promise((resolve, reject) => {
    const ws = client.subscribe(namespace, topicAttributes)) 
    
    ws.on('error', error => {
      console.error('Error in push WebSocket', error)

      // The socket will either stay alive or be replaced on error, this is
      // just to complete our example which expects a single message.
      try {
        ws.close();
      } catch (e) {
        console.error('Websocket is already closed', error);
      } finally {
        reject(error);
      }
    });
    
    ws.on('reconnect', () => console.log('Push WebSocket replaced.'));
    ws.on('open', () => console.log('Push WebSocket established.'));
    ws.on('close', () => {
      console.log('Push WebSocket closed.')
      resolve();
    });

    ws.on('message', message => console.log('Received a message:', message));
    ws.on('ack', messageId => {
      console.log(`Message ${messageId} acknowledged.`);
      ws.close(); // Alias to ws.disconnect()
    });

    ws.on('connectFailed', error => {
      console.error('Error upgrading GET request to WebSocket', error)
      reject(error);
    });
  });
})
.catch(error => {
  console.error(`Error establishing push WebSocket: ${error}\n${error.stack}`);
});
```